package main

// сюда писать код
import (
	"fmt"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"sync"
	"sync/atomic"
)

func ExecutePipeline(jobs ...job) {
	var numOfParallel int
	make2DimChan := func(n int) (chans [][]chan interface{}) {
		for j := 0; j < n; j++ {
			var cs []chan interface{}
			for i := 0; i < len(jobs); i++ {
				cs = append(cs, make(chan interface{}))
			}
			chans = append(chans, cs)
		}
		return
	}
	var chans []chan interface{}
	for i := 0; i < len(jobs); i++ {
		chans = append(chans, make(chan interface{}))
	}
	var num int32
	inc := func() {
		atomic.AddInt32(&num, 1) // автомарно
		runtime.Gosched()
	}
	wg := &sync.WaitGroup{}
	in := make(chan interface{}, 7)
	comb := make(chan interface{})
	bw := make(chan interface{})
	out := make(chan interface{})
	wg.Add(1)
	go func() {
		defer wg.Done()
		jobs[0](in, in)
		numOfParallel = len(in)
		if numOfParallel < 4 {
			numOfParallel = 1
		}
		close(in)
	}()
	wg.Wait()
	if numOfParallel < 4 {
		chans[0] = in
		for i := 1; i < len(jobs); i++ {
			wg.Add(1)
			go func(i int, f job) {
				defer wg.Done()
				f(chans[i-1], chans[i])
				close(chans[i])
			}(i, jobs[i])
		}
	} else {
		fmt.Println(numOfParallel, len(jobs))
		chsBetween := make2DimChan(numOfParallel)
		for k := 1; k < len(jobs)-2; k++ {
			fmt.Println("iter ", k)
			for j := 0; j < numOfParallel; j++ {
				wg.Add(1)
				go func(j, k int, f job) {
					defer wg.Done()
					if k == 1 && numOfParallel == 1 {
						f(in, comb)
						close(comb)
					} else if k == 1 {
						f(in, chsBetween[j][k]) // j = 0..6 k = 1
						close(chsBetween[j][k])
					} else if k < len(jobs)-2 {
						f(chsBetween[j][k-1], bw) // j = 0..6 k = 2
						go inc()
					}
				}(j, k, jobs[k])
			}
		}
		wg.Add(1)
		go func(k int, f job) {
			defer wg.Done()
			f(bw, comb)
			close(comb)
		}(len(jobs)-2, jobs[len(jobs)-2])
		for {
			if atomic.LoadInt32(&num) == int32(numOfParallel) {
				close(bw)
				break
			}
		}
		runtime.Gosched()
		wg.Add(1)
		go func(f job) {
			defer wg.Done()
			f(comb, out)
			close(out)
		}(jobs[len(jobs)-1])
	}
	wg.Wait()
}

func SingleHash(in, out chan interface{}) {
	fmt.Println("SingleHash starts")
	var chans []chan string
	k := 0
	for v := range in {
		s := strconv.Itoa(v.(int))
		chans = append(chans, make(chan string))
		chans = append(chans, make(chan string))
		chans = append(chans, make(chan string))
		go func(s string, res chan string) {
			res <- DataSignerCrc32(s)
		}(s, chans[k])
		go func(s string, out chan string) {
			out <- DataSignerMd5(s)
		}(s, chans[k+1])
		go func(res chan string, in chan string) {
			res <- DataSignerCrc32(<-in)
		}(chans[k+2], chans[k+1])
		k += 3
	}
	for i := 0; i < len(chans); i += 3 {
		res := <-chans[i] + "~" + <-chans[i+2]
		out <- res
	}
	fmt.Println("SingleHash done!")
}

func MultiHash(in, out chan interface{}) {
	fmt.Println("MultiHash starts")
	var chans []chan string
	k := 0
	for v := range in {
		s := v.(string)
		for th := 0; th <= 5; th++ {
			chans = append(chans, make(chan string))
			go func(s string, res chan string, th int) {
				res <- DataSignerCrc32(strconv.Itoa(th) + s)
			}(s, chans[k], th)
			k++
		}
	}
	for i := 0; i < len(chans); i += 6 {
		res := ""
		for j := i; j <= i+5; j++ {
			res += <-chans[j]
		}
		out <- res
	}
	fmt.Println("MultiHash done!")
}

func CombineResults(in, out chan interface{}) {
	fmt.Println("CombineResults start")

	var res []string

	for s := range in {
		res = append(res, s.(string))
	}

	sort.Strings(res)
	out <- strings.Join(res, "_")
	fmt.Println("CombineResults done!")
}
